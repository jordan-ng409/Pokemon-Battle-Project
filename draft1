
# Pokémon Battle simulation
# Authors: Dharmagat Neupane, Jordan Ng, Prakash Dangi
# Many hours were spent on this project but we had a lot of fun working on it. Hope you enjoy!


import random

'''Defining the pokemon class: '''

#This class defines a pokemon and all of it's functions/attributes.

class Pokemon:

    def __init__(self, name, hp, attack):
        self.name = name
        self.hp = hp
        self.attack = attack
        self.max_hp = hp  # used for healing later

    def attack_target(self, target, move_power):
        #Attack another Pokémon and apply damage.
        damage = self.attack + move_power - random.randint(0, 4) #the random number is to add some variability to the attack power, otherwise the attack power is too predictable each time
        if damage < 1:
            damage = 1
        print(f"\nIt dealt {damage} damage!")
        target.take_damage(damage)

    def take_damage(self, amount):
        #Reduce HP when taking damage.
        self.hp = self.hp - amount
        if self.hp < 0:
            self.hp = 0
        print(f"\n{self.name} has {self.hp}/{self.max_hp} HP remaining.")

    def is_fainted(self):
        #Return True if HP is zero.
        return self.hp <= 0


'''This block of code reads from the file that has data of pokemon: '''

#Reads the data from the.csv file and adds them to a list of Pokémon dictionaries.
pokemon_data = []   # list (collection type #1) <------------------------------------

with open("Project/pokemondata.csv","r") as file:
    for line in file:
        line = line.strip()
        name, hp, attack = line.split(",") 
        if name != "Name": #skips over the first line
            pokemon_data.append({"name": name, "hp": int(hp),"attack": int(attack)})


#The rubric said three different collection types so we have tuples, dictionaries, and lists:


'''Moves stored as tuples and inventory stored in dictionary, and a list for captured pokemon'''

MOVES = [("Tackle", 20), ("Growl", 0)]  #collection type 2: These are the available moves for every pokemion stored in a tuple.

inventory = {"Potion": 30, "Pokeball": 50} #collection type 3: These are the available bag items stored in a dictionary.

captured_pokemon = [] #collection type 1: This is a list of the pokemon that get captured. 

strong_pokemon = [] #List of strong pokemon


'''The most important functions'''

'''
The following functions are the basic features of the game which include:
The main menu, the player's turn, choosing a move, using an item, the enemy's turn, and then the battle loop.
'''

#Main menu function
def display_main_menu():
    print("\n==============================")
    print("  Pokémon Battle Simulator")
    print("==============================")
    print("\n1. Battle a Wild Pokémon")
    print("2. Battle a Trainer")
    print("3. View Caught Pokemon")
    print("4. Choose Active Pokemon")
    print("5. Tips")
    print("6. Quit")
    return input("\nChoose an option (1-6): ")


#This function codes the action within player's turn:
def player_turn(player_pokemon, enemy_pokemon, is_trainer = False): #is_trainer is intended to determine whether the fight is a wild battle or trainer battle
    while True:
        print("\nWhat will you do?")
        print("1. Fight")
        print("2. Bag")
        print("3. Run")
        action = input("\nChoose an action: ")
        
        if action == "1":
            move_index = choose_move()
            move_name, move_power = MOVES[move_index-1] 

            # The move growl does not do any damage, it only lowers the opposing pokemon's attack.
            if move_name == "Growl":
                print(f"\n{player_pokemon.name} used Growl!")
                if enemy_pokemon.attack > 1: 
                    enemy_pokemon.attack -= 1
                    print(f"\nEnemy {enemy_pokemon.name}'s attack fell!")
                else:
                    print("\nBut it had no effect!")
            else:
                print(f"\n{player_pokemon.name} used {move_name}!")
                player_pokemon.attack_target(enemy_pokemon, move_power)

            return None #This is to ensure that the battle loops
        
        elif action == "2":
            result = use_item(player_pokemon, enemy_pokemon, is_trainer)
            if result == "caught":
                return "caught"
            if result == "used_item":
                return None
            
        elif action == "3":
            if is_trainer:
                print("\nYou can't run from a Trainer Battle!")
                return None
            print("\nYou got away safely!")
            return "run"

        else:
            print("\nThat's not an option!")

#Function that lets the player choose a move:
def choose_move():
    
    while True:
        print("\nChoose a move:")
        move_number = 1
        for move in MOVES: #<------------- calling the moves from the MOVES tuple
            print(f"{move_number}. {move[0]}")
            move_number += 1

        choice = input("\nMove: ")
        if choice in ["1", "2"]:
            return int(choice) 
        
        print("\nInvalid move. Try again.")

#This function allows for the item functionality, letting the player heal or catch wild pokemon:
def use_item(player_pokemon, enemy_pokemon, is_trainer):
    print("\nYour Bag:")
    print(f"1. Potion ({inventory['Potion']} left)")
    print(f"2. Pokeball ({inventory['Pokeball']} left)")
    print("3. Cancel")

    choice = input("\nChoose an item: ")

    # POTION
    # Since we wanted the item quantity to be the value in the dictionary, we decided to have the potion's healing function to be within a nested selection statement

    if choice == "1":
        if inventory["Potion"] > 0:
            inventory["Potion"] -= 1
            heal_amount = 20
            player_pokemon.hp += heal_amount
            if player_pokemon.hp > player_pokemon.max_hp:
                player_pokemon.hp = player_pokemon.max_hp
            print(f"\nYou used a Potion! {player_pokemon.name} healed 20 HP!")
            print(f"{player_pokemon.name} now has {player_pokemon.hp}/{player_pokemon.max_hp} HP.")
            return "used_item"
        else:
            print("\nYou have no Potions left!")
            return None

    # POKEBALL
    # The functionality of the pokeball is also contained within a nested selection statement here:
    elif choice == "2":
        if is_trainer:
            print("\nYou can't catch a Trainer's Pokémon!")
            return None

        if inventory["Pokeball"] > 0:
            inventory["Pokeball"] -= 1

            # Simple catch formula designed by Prakash
            chance = (enemy_pokemon.max_hp - enemy_pokemon.hp) / enemy_pokemon.max_hp #If a pokemon has max hp of 400 but it has 100 hp remaining, there is a 75% chance to catch it.
            roll = random.random() #this gives a random float between 0.0 and 1.0
            print(f"\nYou threw a Pokéball!")
            if roll < chance: #this compares the value of the roll vs the actual chance to catch the pokemon. if the chance is higher than the roll, then the pokemon is caught. it is a very effective way to calculate the probability that we came up with. 
                print(f"\n*** You caught {enemy_pokemon.name}! ***")
                return "caught" #refer to line 238
            
            else:
                print("\nOh no! It broke free!")
                return "used_item" 
        else:
            print("\nYou have no Pokeballs left!")
            return None

    # CANCEL
    else:
        return None

#This function is for the enemy's turn:
def enemy_turn(enemy_pokemon, player_pokemon):
    print("\n..........") #just a line intended to indicate when the opponent makes a move
    move_name, move_power = random.choice(MOVES) #we learned that the random.choice feature is an easy way to select a random item from a list, dictionary, or tuple, so we have utilized it a few times throughout the code.

    #Just like the trainer, the enemy pokemon is given the ability to use growl
    if move_name == "Growl":
        print(f"\nEnemy {enemy_pokemon.name} used Growl!")
        if player_pokemon.attack > 1:
            player_pokemon.attack -= 1
            print(f"\n{player_pokemon.name}'s attack fell!")
        else:
            print(f"\nBut it had no effect!")

    # This section is for if the enemy's move is tackle.
    else:
        print(f"\nEnemy {enemy_pokemon.name} used {move_name}!")
        enemy_pokemon.attack_target(player_pokemon, move_power)

#This function is the main battle loop, recalling the player_turn and enemy_turn functions:
def battle_loop(player_pokemon, enemy_pokemon, is_trainer = False):
    if is_trainer:
        print(f"\nOpposing Trainer sent out {enemy_pokemon.name}!")
    else:
        print(f"\nA wild {enemy_pokemon.name} appeared!")

    print(f"\nGo, {player_pokemon.name}!")

    while True:
        result = player_turn(player_pokemon, enemy_pokemon, is_trainer)
        if result == "run":
            break
        
        #For when a pokemon is caught
        if result == "caught":
            print(f"\nYou successfully captured {enemy_pokemon.name}!")
            captured_pokemon.append(enemy_pokemon.name)
            print(f"{enemy_pokemon.name} was added to your box.")
            break

        #If the enemy's pokemon fainted
        if enemy_pokemon.is_fainted():
            print(f"Enemy {enemy_pokemon.name} fainted! You win!")
            break
        enemy_turn(enemy_pokemon, player_pokemon)

        #When your pokemon faints
        if player_pokemon.is_fainted():
            print(f"{player_pokemon.name} fainted! You lost!")
            break


'''This function is the main part of the game'''


#The main purpose of this function is to give functionality to the main menu display. It also loads information from the file using the file function we created, and also recalls the battle_loop function, putting everything together.

def main():
    active_pokemon_name = "Pikachu" # this is the currently active pokemon. 
    
    #We created a weighted wild pokemon list in order to determine the probability in which the pokemon can appear. Since there is a mix of strong and weaker pokemon from the .csv file, we wanted to even it out by making the stronger ones more rare.

    '''The following percentages were calculated on the following logic: 
        if one weak pokemon is added to the list, is added 10 times. If a 
        medium strength pokemon is added, it is added 5 times to the list. 
        If a strong pokemon is added to the list it is added 2 times. And of 
        course, Mewtwo is only added once. In the list which has a total of 18
        pokemon, 10/18 is 55.55%, 5/18 is 27.7%, 2/18 is 11%, and 1/18 is 5.5%.
        Therefore, if you wanted to tweak the rates you could change how much 
        pokemon to add to the list and how much of it to append to the list. '''
    
    def weighted_wild_list(pokemon_data):
        weighted_list = []
        for mon in pokemon_data:
            hp = mon["hp"]

            # Weakest tier pokemon
            if hp < 300:
                for i in range(10):   # about a 55.5% chance to appear, appended to the list 10 times
                    weighted_list.append(mon)

            # Medium tier strength pokemon
            elif hp < 700:
                for i in range(5):    # about a 27.7% chance to appear, appended to the list 5 times
                    weighted_list.append(mon)

            # Strongest pokemon
            elif hp < 900:
                for i in range(2):    # about a 11% chance to appear, appended to the list 2 times
                    weighted_list.append(mon)

            # Mewtwo
            else:
                weighted_list.append(mon)   # a 5.5% chance to appear. good luck finding it. appended to the list only once.

        return weighted_list

    weighted_wild = weighted_wild_list(pokemon_data)

    #The first five pokemon in the list are automatically given to the player so that they can choose whom to use. 
    count = 0
    for mon in pokemon_data:
        if count < 5:
            captured_pokemon.append(mon["name"])
            count += 1
        else:
            break

    #This determines strong pokemon, hence the condition being pokemon being over 700 hp. The trainer will have a randomly chosen pokemon among the strong. Idea by Dharma
    for mon in pokemon_data:
        if mon["hp"] >= 700 and mon["hp"]<= 900: 
            strong_pokemon.append(mon)

    #The main loop!
    while True:  
        choice = display_main_menu() #Choice = display_main_menu() because it is an input waiting for an answer.

        if choice == "1":
            #For the wild pokemon battle, a random pokemon from the list of 40 will be chosen. They all have an equal chance to appear. 

            player_info = pokemon_data[0] # makes Pikachu the default starter pokemon
            for mon in pokemon_data:
                if mon["name"] == active_pokemon_name: 
                    player_info = mon #updates the player info if the player chooses a different active pokemon
                    break

            player = Pokemon(player_info["name"], player_info["hp"], player_info["attack"])
            wild_info = random.choice(weighted_wild) #This allows for a wild pokemon to be chosen from the .csv file
            enemy = Pokemon(wild_info["name"], wild_info["hp"], wild_info["attack"]) 
            battle_loop(player, enemy, is_trainer=False) #This determines whether the battle is a trainer battle or a wild pokemon

        elif choice == "2":
            #choice 2 is written essentially the same as choice 1 except since it is a trainer battle, we have to differentiate that it is one.

            player_info = pokemon_data[0] # makes Pikachu the default starter pokemon
            for mon in pokemon_data:
                if mon["name"] == active_pokemon_name:
                    player_info = mon #updates the player info if the player chooses a different active pokemon
                    break

            player = Pokemon(player_info["name"], player_info["hp"], player_info["attack"])
            trainer_info = random.choice(strong_pokemon) #unlike choice one, we pick a random pokemon from the pool of strong pokemon.
            enemy = Pokemon(trainer_info["name"], trainer_info["hp"], trainer_info["attack"])
            battle_loop(player, enemy, is_trainer=True)

        elif choice == "3":
        # This choice allows you to view captured Pokémon
            print("\n===== Your Pokemon Collection =====")

            if not captured_pokemon: #Displays this message if you have no pokemon 
                print("You haven't caught any Pokémon yet! :(")
            else:
                for mon in captured_pokemon:
                    print(f"- {mon}")
            print("===================================")

        elif choice == "4":
        #This choice allows the player to switch their active pokemon in the main menu. Unfortunately, your active pokemon cannot be switched mid-battle so we just put the feature in the main menu.
            print("\==== Choose Your Active Pokemon ====")

            available_pokemon = ["Pikachu"] #the currently active pokemon
            for name in captured_pokemon:
                if name not in available_pokemon:
                    available_pokemon.append(name) #updates the available pokemon list with the pokemon in the captured list

            number = 1
            for name in available_pokemon: #this orders the available pokemon by number
                print(str(number) + ". " + name)
                number += 1

            '''We wrote the following section of code after learning about exceptions in class so we tried adding it here: '''
    
            while True:
                pick = input("Choose a Pokémon number: ")
                try:
                    pick = int(pick)
                except ValueError: #if a letter or other character that's not a number is typed in
                    print("That's not a number! Try again.")
                    continue  

                if pick < 1 or pick > len(available_pokemon): #if the number chosen is not within the number of available pokemon
                    print("That number is not an option. Try again.")
                    continue

                active_pokemon_name = available_pokemon[pick - 1] #a successful pick
                print(f"\nYour active pokemon is now {active_pokemon_name}.")
                break
        
        elif choice == "5":
        #This choice displays tips that we have created in order to fully enjoy the game.
            print("\nHere are some tips :) ")
            print("\n- You can switch out your starter pokemon in the main menu. There are 5 options to choose from.")
            print("\n- There are many wild pokemon available. Try to catch stronger ones in order to beat the trainer.")
            print("\n- If you jump straight into a trainer fight from the get-go, you might get cooked.")
            print("\n- If you are struggling with catching a wild pokemon, try lowering it's health first.")
            print("\n- Using growl against a stronger pokemon can help you survive by lowering it's attacking power.")
            print("\n- There is no level up function so if you encounter a stronger pokemon in the wild, you can either try to catch it or just run lol.")
            print("\n- If you are low on hp, use your potions.")
            print("\n- Unfortunately we did not add types into the game so there is no type advantage/type advantage moves. On the flip side, it adds a strategic challenge to the game.")
            print("\n- There is a rare chance to encounter a certain legendary pokemon in the wild. Good luck if you find it.") 

        elif choice == "6":
            print("Thanks for playing! Credits: Dharmagat Neupane, Jordan Ng, and Prakash Dangi. ")
            break

        else:
            print("That's not an option.")


if __name__ == "__main__":
    main()
