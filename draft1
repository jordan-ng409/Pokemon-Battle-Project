
# Pokémon Battle simulation
# Authors: Dharmagat Neupane, Jordan Ng, Prakash Dangi
# Many hours were spent on this project but we had a lot of fun working on it. Hope you enjoy!


import random

'''Defining the pokemon class: '''

#This class defines a pokemon and all of it's functions/attributes.

class Pokemon:

    def __init__(self, name, hp, attack):
        self.name = name #a pokemon's name
        self.hp = hp #a pokemon's hp stat within the battle
        self.attack = attack #a pokemon's attack stat
        self.max_hp = hp  # used for healing later and to calculate catch probability for wild pokemon. refer to line 166 and line 186

    def attack_target(self, target, move_power):
        #Attack another Pokémon and apply damage.
        damage = self.attack + move_power - random.randint(0, 4) #the random number is to add some variability to the attack power, otherwise the attack power is too predictable each time
        if damage < 1: #this is to ensure that the damage cannot below 1
            damage = 1
        print(f"\nIt dealt {damage} damage!") #this message will appear during the battle showing how much damage the move dealt.
        target.take_damage(damage)

    def take_damage(self, amount):
        #Reduces HP when taking damage.
        self.hp = self.hp - amount
        if self.hp < 0: #this is to ensure that the hp cannot go below 0
            self.hp = 0
        print(f"\n{self.name} has {self.hp}/{self.max_hp} HP remaining.") #message to show how much health is remaining

    def is_fainted(self):
        #Return True if HP is zero.
        return self.hp <= 0


'''The following block of code reads from the file that has data of pokemon: '''

#Reads the data from the.csv file and adds them to a list of Pokémon dictionaries.
pokemon_data = []   # list (collection type #1) <------------------------------------

with open("Project/pokemondata.csv","r") as file:
    for line in file:
        line = line.strip()
        name, hp, attack = line.split(",") #splits the columns
        if name != "Name": #skips over the first line
            pokemon_data.append({"name": name, "hp": int(hp),"attack": int(attack)})


#The rubric said three different collection types so we have tuples, dictionaries, and lists:

'''Moves stored as tuples, inventory stored in a dictionary, and a list for captured and strong pokemon'''

MOVES = [("Tackle", 20), ("Growl", 0)]  #collection type 2: These are the available moves for every pokemion stored in a tuple.

inventory = {"Potion": 30, "Pokeball": 50} #collection type 3: These are the available bag items stored in a dictionary.

captured_pokemon = [] #collection type 1: This is a list of the pokemon that get captured. refer to line 303 - 309

strong_pokemon = [] #List of strong pokemon: refer to line 312 - 314


'''The most important functions'''

'''
The following functions are the basic features of the game which include:
The main menu, the player's turn, choosing a move, using an item, the enemy's turn, and then the battle loop.
'''

#Main Menu function:
'''This is the main menu display. Refer to line 318 - 410 which gives the main menu it's functionality'''
def display_main_menu():
    print("\n==============================")
    print("  Pokémon Battle Simulator")
    print("==============================")
    print("\n1. Battle a Wild Pokémon")
    print("2. Battle a Trainer")
    print("3. View Caught Pokemon")
    print("4. Choose Active Pokemon")
    print("5. Tips")
    print("6. Quit")
    return input("\nChoose an option (1-6): ") #allows the player to input their choice

#Player's Turn function:
'''This function dictates what happens in the player's turn'''
def player_turn(player_pokemon, enemy_pokemon, is_trainer = False): #is_trainer is intended to determine whether the fight is a wild battle or trainer battle. refer to line 125
    while True:
        print("\nWhat will you do?")
        print("1. Fight")
        print("2. Bag")
        print("3. Run")
        action = input("\nChoose an action: ") #allows the player to input their choice
        
        if action == "1":
            move_index = choose_move() #calls the Choose Move function (line 135) 
            move_name, move_power = MOVES[move_index-1] #the move name and move power is called from the tuple in line 58

            # The move growl does not do any damage, it only lowers the opposing pokemon's attack.
            if move_name == "Growl":
                print(f"\n{player_pokemon.name} used Growl!")
                if enemy_pokemon.attack > 1: #only works if the enemy pokemon has at least 1 attack.
                    enemy_pokemon.attack -= 1
                    print(f"\nEnemy {enemy_pokemon.name}'s attack fell!")
                else:
                    print("\nBut it had no effect!") #error message
            else:
                print(f"\n{player_pokemon.name} used {move_name}!")
                player_pokemon.attack_target(enemy_pokemon, move_power)

            return None #This is to ensure that the battle loops
        
        elif action == "2":
            result = use_item(player_pokemon, enemy_pokemon, is_trainer) #calls the Use Item function (line 152)
            if result == "caught":
                return "caught"
            if result == "used_item":
                return None
            
        elif action == "3":
            if is_trainer:
                print("\nYou can't run from a Trainer Battle!") #Since in the actual games, you cannot run away in a trainer fight hence one of the reasons we had to differentiate the two.
                return None
            print("\nYou got away safely!") #If you're fighting a wild pokemon then you run away safely
            return "run"

        else:
            print("\nThat's not an option!") #an error message if you dont choose a valid number or letter

#Choose Move function:
'''This function lets you select a move'''
def choose_move():
    
    while True:
        print("\nChoose a move:")
        move_number = 1
        for move in MOVES: #calling the moves from the MOVES tuple
            print(f"{move_number}. {move[0]}") #Example, it prints "1. Tackle"
            move_number += 1 #for the next move in the tuple, it moves the count up and prints the next move. 

        choice = input("\nMove: ")
        if choice in ["1", "2"]:
            return int(choice) #allows for the player to select either 1 or 2 (there are only two options for moves sorry lol)
        
        print("\nInvalid move. Try again.") #error message

#Use Item function:
'''This function allows for the bag functionality, letting the player heal or catch wild pokemon:'''
def use_item(player_pokemon, enemy_pokemon, is_trainer):
    print("\nYour Bag:")
    print(f"1. Potion ({inventory['Potion']} left)") #this is why using a dictionary for the item bag was helpful
    print(f"2. Pokeball ({inventory['Pokeball']} left)")
    print("3. Cancel") #this lets you cancel out of the bag menu if you choose to proceed with a different option instead

    choice = input("\nChoose an item: ") #player inputs their choice (1-3)

    # POTION
    # Since we wanted the item quantity to be the value in the dictionary, we decided to have the potion's healing function to be within a nested selection statement

    if choice == "1":
        if inventory["Potion"] > 0: #if there are more than 0 potions, the value is reduced by one
            inventory["Potion"] -= 1
            heal_amount = 20 #this is how much hp a potion heals
            player_pokemon.hp += heal_amount
            if player_pokemon.hp > player_pokemon.max_hp: #ensures that the pokemon's hp cannot heal higher than it's max hp
                player_pokemon.hp = player_pokemon.max_hp
            print(f"\nYou used a Potion! {player_pokemon.name} healed 20 HP!") #the message that appears when a potion is used
            print(f"{player_pokemon.name} now has {player_pokemon.hp}/{player_pokemon.max_hp} HP.")
            return "used_item"
        else:
            print("\nYou have no Potions left!") #if no potions are left
            return None

    # POKEBALL
    # The functionality of the pokeball is also contained within a nested selection statement here:
    elif choice == "2":
        if is_trainer:
            print("\nYou can't catch a Trainer's Pokémon!") #Again, just like in the games you cannot catch a trainer's pokemon so it will prompt you with this message
            return None

        if inventory["Pokeball"] > 0: #If you have more than 0 pokeballs in your inventory, it will decrease the number by one with a use
            inventory["Pokeball"] -= 1

            # Simple catch formula designed by Prakash
            chance = (enemy_pokemon.max_hp - enemy_pokemon.hp) / enemy_pokemon.max_hp #If a pokemon has max hp of 400 but it has 100 hp remaining, there is a 75% chance to catch it.
            roll = random.random() #this gives a random float between 0.0 and 1.0
            print(f"\nYou threw a Pokéball!")
            if roll < chance: #this compares the value of the roll vs the actual chance to catch the pokemon. if the chance is higher than the roll, then the pokemon is caught. it is a very effective way to calculate the probability that we came up with. 
                print(f"\n*** You caught {enemy_pokemon.name}! ***")
                return "caught" #refer to line 242
            
            else:
                print("\nOh no! It broke free!") #if the pokemon doesnt wanna get caught
                return "used_item" 
        else:
            print("\nYou have no Pokeballs left!") #if you have no pokeballs left :(
            return None

    # CANCEL
    else:
        return None

#Enemy Turn function:
'''This function works the same as the player's turn, except with slight differences.'''
def enemy_turn(enemy_pokemon, player_pokemon):
    print("\n..........") #just a line intended to indicate when the opponent makes a move
    move_name, move_power = random.choice(MOVES) #we learned that the random.choice feature is an easy way to select a random item from a list, dictionary, or tuple, so we have utilized it a few times throughout the code.

    #Just like the trainer, the enemy pokemon is given the ability to use growl
    if move_name == "Growl":
        print(f"\nEnemy {enemy_pokemon.name} used Growl!")
        if player_pokemon.attack > 1:
            player_pokemon.attack -= 1
            print(f"\n{player_pokemon.name}'s attack fell!")
        else:
            print(f"\nBut it had no effect!")

    # This section is for if the enemy's move is tackle.
    else:
        print(f"\nEnemy {enemy_pokemon.name} used {move_name}!")
        enemy_pokemon.attack_target(player_pokemon, move_power)

#Battle loop function
'''This function is the main battle loop, recalling the player_turn and enemy_turn functions:'''
def battle_loop(player_pokemon, enemy_pokemon, is_trainer = False): #we use if_trainer again to differentiate between a wild pokemon battle vs a trainer battle
    if is_trainer:
        print(f"\nOpposing Trainer sent out {enemy_pokemon.name}!") #trainer battle message
    else:
        print(f"\nA wild {enemy_pokemon.name} appeared!") #wild pokemon message

    print(f"\nGo, {player_pokemon.name}!") #your pokemon

    while True:
        result = player_turn(player_pokemon, enemy_pokemon, is_trainer)
        if result == "run":
            break
        
        #For when a pokemon is caught
        if result == "caught":
            print(f"\nYou successfully captured {enemy_pokemon.name}!")
            captured_pokemon.append(enemy_pokemon.name) #once the pokemon is caught, it is added to the captured pokemon list (line 62)
            print(f"{enemy_pokemon.name} was added to your box.")
            break

        #If the enemy's pokemon fainted
        if enemy_pokemon.is_fainted():
            print(f"Enemy {enemy_pokemon.name} fainted! You win!") #message if you win the fight
            break
        enemy_turn(enemy_pokemon, player_pokemon)

        #When your pokemon faints
        if player_pokemon.is_fainted():
            print(f"{player_pokemon.name} fainted! You lost!") #message if you lose
            break

#Main function
'''This function is the main part of the game.
    The main purpose of this function is to give functionality to the main menu display. It also loads information from the file we created, 
    and also recalls the battle_loop function, putting everything together.'''
def main():
    active_pokemon_name = "Pikachu" # this is the currently active pokemon. 
    
    '''The following percentages were calculated on the following logic: 
        if one weak pokemon is added to the list, is added 10 times. If a 
        medium strength pokemon is added, it is added 5 times to the list. 
        If a strong pokemon is added to the list it is added 2 times. And of 
        course, Mewtwo is only added once. In the list which has a total of 18
        pokemon, 10/18 is 55.55%, 5/18 is 27.7%, 2/18 is 11%, and 1/18 is 5.5%.
        Therefore, if you wanted to tweak the rates you could change how much 
        pokemon to add to the list and how much of it to append to the list. '''
    
    def weighted_wild_list(pokemon_data):
        #We created a weighted wild pokemon list in order to determine the probability in which the pokemon can appear. Since there is a mix of strong and weaker pokemon from the .csv file, we wanted to even it out by making the stronger ones more rare.
        weighted_list = []
        for mon in pokemon_data: #for the pokemon in the pokemon_data list. mon is just short for pokemon if you were wondering
            hp = mon["hp"]

            # Weakest tier pokemon
            if hp < 300:
                for i in range(10):   # about a 55.5% chance to appear, appended to the list 10 times
                    weighted_list.append(mon)

            # Medium tier strength pokemon
            elif hp < 700:
                for i in range(5):    # about a 27.7% chance to appear, appended to the list 5 times
                    weighted_list.append(mon)

            # Strongest pokemon
            elif hp < 900:
                for i in range(2):    # about a 11% chance to appear, appended to the list 2 times
                    weighted_list.append(mon)

            # Mewtwo
            else:
                weighted_list.append(mon)   # a 5.5% chance to appear. good luck finding it. appended to the list only once.

        return weighted_list

    weighted_wild = weighted_wild_list(pokemon_data) #the weighted wild is equal to the result of the function

    #The first five pokemon in the list are automatically given to the player so that they can choose whom to use. 
    count = 0
    for mon in pokemon_data:
        if count < 5:
            captured_pokemon.append(mon["name"]) #essentially, these are the starter pokemon
            count += 1
        else:
            break

    #This determines strong pokemon, hence the condition being pokemon being over 700 hp. The trainer will have a randomly chosen pokemon among the strong. Idea by Dharma
    for mon in pokemon_data:
        if mon["hp"] >= 700 and mon["hp"]<= 900: 
            strong_pokemon.append(mon) #refer to line 64

    #The main loop
    while True:  
        choice = display_main_menu() #Choice = display_main_menu() because it is an input waiting for an answer.

        if choice == "1": #Wild Pokemon battle
            #For the wild pokemon battle, a random pokemon from the list of 40 will be chosen based on the weighted pokemon list

            player_info = pokemon_data[0] # makes Pikachu the default starter pokemon
            for mon in pokemon_data:
                if mon["name"] == active_pokemon_name: 
                    player_info = mon #updates the player info if the player chooses a different active pokemon
                    break

            player = Pokemon(player_info["name"], player_info["hp"], player_info["attack"]) #player info is essentially is the pokemon's name, hp, and attack for the session.
            wild_info = random.choice(weighted_wild) #chooses a wild pokemon to be chosen from the .csv file based on the weight
            enemy = Pokemon(wild_info["name"], wild_info["hp"], wild_info["attack"]) #assigns the wild pokemon's info
            battle_loop(player, enemy, is_trainer=False) #This determines whether the battle is a trainer battle or a wild pokemon

        elif choice == "2": #Trainer Battle
            #choice 2 is written essentially the same as choice 1 except since it is a trainer battle, we have to differentiate that it is one.

            player_info = pokemon_data[0] # makes Pikachu the default starter pokemon
            for mon in pokemon_data:
                if mon["name"] == active_pokemon_name:
                    player_info = mon #updates the player info if the player chooses a different active pokemon
                    break

            player = Pokemon(player_info["name"], player_info["hp"], player_info["attack"])
            trainer_info = random.choice(strong_pokemon) #unlike choice one, we pick a random pokemon from the pool of strong pokemon.
            enemy = Pokemon(trainer_info["name"], trainer_info["hp"], trainer_info["attack"])
            battle_loop(player, enemy, is_trainer=True)

        elif choice == "3":
        # This choice allows you to view captured Pokémon
            print("\n===== Your Pokemon Collection =====")

            if not captured_pokemon: #Displays this message if you have no pokemon 
                print("You haven't caught any Pokémon yet! :(")
            else:
                for mon in captured_pokemon:
                    print(f"- {mon}")
            print("===================================")

        elif choice == "4":
        #This choice allows the player to switch their active pokemon in the main menu. Unfortunately, your active pokemon cannot be switched mid-battle so we just put the feature in the main menu.
            print("\==== Choose Your Active Pokemon ====")

            available_pokemon = ["Pikachu"] #the currently active pokemon
            for name in captured_pokemon:
                if name not in available_pokemon:
                    available_pokemon.append(name) #updates the available pokemon list with the pokemon in the captured list

            number = 1
            for name in available_pokemon: #this orders the available pokemon by number
                print(str(number) + ". " + name)
                number += 1

            '''We wrote the following section of code after learning about exceptions in class so we tried adding it here: '''
    
            while True:
                pick = input("Choose a Pokémon number: ")
                try:
                    pick = int(pick)
                except ValueError: #if a letter or other character that's not a number is typed in
                    print("That's not a number! Try again.")
                    continue  

                if pick < 1 or pick > len(available_pokemon): #if the number chosen is not within the number of available pokemon
                    print("That number is not an option. Try again.")
                    continue

                active_pokemon_name = available_pokemon[pick - 1] #a successful pick
                print(f"\nYour active pokemon is now {active_pokemon_name}.")
                break
        
        elif choice == "5":
        #This choice displays tips that we have created in order to fully enjoy the game.
            print("\nHere are some tips :) ")
            print("\n- You can switch out your starter pokemon in the main menu. There are 5 options to choose from.")
            print("\n- There are many wild pokemon available. Try to catch stronger ones in order to beat the trainer.")
            print("\n- If you jump straight into a trainer fight from the get-go, you might get cooked.")
            print("\n- If you are struggling with catching a wild pokemon, try lowering it's health first.")
            print("\n- Using growl against a stronger pokemon can help you survive by lowering it's attacking power.")
            print("\n- There is no level up function so if you encounter a stronger pokemon in the wild, you can either try to catch it or just run lol.")
            print("\n- If you are low on hp, use your potions.")
            print("\n- Unfortunately we did not add types into the game so there is no type advantage/type advantage moves. On the flip side, it adds a strategic challenge to the game.")
            print("\n- There is a rare chance to encounter a certain legendary pokemon in the wild. Good luck if you find it.") 

        elif choice == "6":
            print("Thanks for playing! Credits: Dharmagat Neupane, Jordan Ng, and Prakash Dangi. ")
            break

        else:
            print("That's not an option.")

if __name__ == "__main__":
    main()

'''This makes sure the game only starts when we run this file. If someone imports
    the file into another file, the game won't start by itself'''

#THE END
